/**
 * Copyright (c) 2019 shogogg <shogo@studofly.net>
 *
 * This software is released under the MIA License.
 * http://opensource.org/licenses/mit-license.php
 */
export interface Matcher<A, B> {
    some: (_: A) => B;
    none: () => B;
}
export interface OptionLike<A> {
    /**
     * Returns true if the option is non-empty and the predicate p returns true when applied to the option's value.
     */
    exists(p: (_: A) => boolean): boolean;
    /**
     * Returns the option if it is non-empty and applying the predicate p to the option's value returns true.
     */
    filter(p: (_: A) => boolean): Option<A>;
    /**
     * Returns the option if it is non-empty and applying the predicate p to the option's value returns false.
     */
    filterNot(p: (_: A) => boolean): Option<A>;
    /**
     * Returns the result of applying f to the option's value if the option is non-empty.
     */
    flatMap<B>(f: (_: A) => Option<B>): Option<B>;
    /**
     * Returns the result of applying f to the option's value if the option is non-empty.
     * Otherwise, evaluates expression ifEmpty.
     */
    fold<B>(ifEmpty: () => B): (f: (_: A) => B) => B;
    /**
     * Tests whether a predicate holds for all elements of the option.
     */
    forAll(p: (_: A) => boolean): boolean;
    /**
     * Performs a for-comprehension like flatMap and map operation using the given functions
     */
    forComprehension(...fns: ((x: any) => Option<any>)[]): Option<any>;
    /**
     * Apply the given procedure f to the option's value, if it is non-empty.
     */
    forEach(f: (_: A) => void): void;
    /**
     * Returns the option's value if the option is non-empty, otherwise throws an error.
     */
    readonly get: A;
    /**
     * Returns the option's value if the option is non-empty, otherwise return the result of evaluating defaultValue.
     */
    getOrElse(defaultValue: () => A): A;
    /**
     * Returns the option's value if the option is non-empty, otherwise return defaultValue.
     */
    getOrElseValue(defaultValue: A): A;
    /**
     * Returns true if the option's value is non-empty, false otherwise.
     */
    readonly isDefined: boolean;
    /**
     * Returns true if the option's value is empty, false otherwise.
     */
    readonly isEmpty: boolean;
    /**
     * Builds a new option by applying a function to all elements of this option.
     */
    map<B>(f: (_: A) => B): Option<B>;
    /**
     * Pattern match signature.
     */
    match<B>(matcher: Matcher<A, B>): B;
    /**
     * Returns true if the option's value is non-empty, false otherwise.
     */
    readonly nonEmpty: boolean;
    /**
     * Returns the option itself if it is non-empty, otherwise return the result of evaluating alternative.
     */
    orElse(alternative: () => Option<A>): Option<A>;
    /**
     * Returns the option itself if it is non-empty, otherwise return the alternative.
     */
    orElseValue(alternative: Option<A>): Option<A>;
    /**
     * Returns the option's value if it is non-empty, or null if it is empty.
     */
    readonly orNull: A | null;
    /**
     * Returns the option's value if it is non-empty, or undefined if it is empty.
     */
    readonly orUndefined: A | undefined;
    /**
     * Converts the option to an array.
     */
    readonly toArray: A[];
    /**
     * Returns a string representation
     */
    toString(): string;
}
export declare abstract class Option<A> implements OptionLike<A> {
    abstract exists(p: (_: A) => boolean): boolean;
    abstract filter(p: (_: A) => boolean): Option<A>;
    abstract filterNot(p: (_: A) => boolean): Option<A>;
    abstract flatMap<B>(f: (_: A) => Option<B>): Option<B>;
    abstract fold<B>(ifEmpty: () => B): (f: (_: A) => B) => B;
    abstract forAll(p: (_: A) => boolean): boolean;
    abstract forComprehension(...fns: ((x: any) => Option<any>)[]): Option<any>;
    abstract forEach(f: (_: A) => void): void;
    readonly get: A;
    abstract getOrElse(defaultValue: () => A): A;
    abstract getOrElseValue(defaultValue: A): A;
    readonly isDefined: boolean;
    readonly isEmpty: boolean;
    abstract map<B>(f: (_: A) => B): Option<B>;
    abstract match<B>(matcher: Matcher<A, B>): B;
    readonly nonEmpty: boolean;
    abstract orElse(alternative: () => Option<A>): Option<A>;
    abstract orElseValue(alternative: Option<A>): Option<A>;
    readonly orNull: A | null;
    readonly orUndefined: A | undefined;
    readonly toArray: A[];
    abstract toString(): string;
}
export declare class Some<A> extends Option<A> implements OptionLike<A> {
    private readonly value;
    constructor(value: A);
    exists(p: (_: A) => boolean): boolean;
    filter(p: (_: A) => boolean): Option<A>;
    filterNot(p: (_: A) => boolean): Option<A>;
    flatMap<B>(f: (_: A) => Option<B>): Option<B>;
    fold<B>(): (f: (_: A) => B) => B;
    forAll(p: (_: A) => boolean): boolean;
    forComprehension(...fns: ((x: any) => Option<any>)[]): Option<any>;
    forEach(f: (_: A) => void): void;
    get get(): A;
    getOrElse(): A;
    getOrElseValue(): A;
    get isDefined(): boolean;
    get isEmpty(): boolean;
    map<B>(f: (_: A) => B): Option<B>;
    match<B>(matcher: Matcher<A, B>): B;
    get nonEmpty(): boolean;
    orElse(): Option<A>;
    orElseValue(): Option<A>;
    get orNull(): A | null;
    get orUndefined(): A | undefined;
    get toArray(): A[];
    toString(): string;
}
export declare class None<A> extends Option<A> implements OptionLike<A> {
    exists(): boolean;
    filter(): Option<A>;
    filterNot(): Option<A>;
    flatMap<B>(): Option<B>;
    fold<B>(ifEmpty: () => B): (f: (_: A) => B) => B;
    forAll(): boolean;
    forComprehension(): Option<any>;
    forEach(): void;
    get get(): A;
    getOrElse(defaultValue: () => A): A;
    getOrElseValue(defaultValue: A): A;
    get isDefined(): boolean;
    get isEmpty(): boolean;
    map<B>(): Option<B>;
    match<B>(matcher: Matcher<A, B>): B;
    get nonEmpty(): boolean;
    orElse(alternative: () => Option<A>): Option<A>;
    orElseValue(alternative: Option<A>): Option<A>;
    get orNull(): A | null;
    get orUndefined(): A | undefined;
    get toArray(): Array<A>;
    toString(): string;
}
export declare function some<A>(value: A): Option<A>;
export declare const none: Option<never>;
export declare function option<A>(value?: A | null): Option<A>;
